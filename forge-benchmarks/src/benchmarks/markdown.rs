//! Markdown generation for benchmark results.
//!
//! This module provides utilities for generating Markdown-formatted
//! benchmark reports from `BenchmarkResult` collections.

use super::result::BenchmarkResult;
use chrono::Utc;

/// Generates a Markdown summary report from benchmark results.
///
/// # Arguments
///
/// * `results` - Slice of benchmark results to include in the report
///
/// # Returns
///
/// A formatted Markdown string containing the benchmark summary.
///
/// # Example
///
/// ```rust
/// use forge_benchmarks::benchmarks::result::BenchmarkResult;
/// use forge_benchmarks::benchmarks::markdown::generate_summary;
/// use serde_json::json;
///
/// let results = vec![
///     BenchmarkResult::new("target-1".to_string(), json!({"ops_per_sec": 1000000})),
/// ];
///
/// let markdown = generate_summary(&results);
/// assert!(markdown.contains("target-1"));
/// ```
pub fn generate_summary(results: &[BenchmarkResult]) -> String {
    let mut md = String::new();

    // Header
    md.push_str("# LLM-Forge Benchmark Results\n\n");
    md.push_str(&format!(
        "**Generated:** {}\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    // Summary statistics
    let total = results.len();
    let failed = results.iter().filter(|r| r.is_failed()).count();
    let passed = total - failed;

    md.push_str("## Summary\n\n");
    md.push_str(&format!("- **Total Benchmarks:** {}\n", total));
    md.push_str(&format!("- **Passed:** {}\n", passed));
    md.push_str(&format!("- **Failed:** {}\n\n", failed));

    // Results table
    md.push_str("## Results\n\n");
    md.push_str("| Target ID | Status | Ops/sec | Avg (ns) | Timestamp |\n");
    md.push_str("|-----------|--------|---------|----------|----------|\n");

    for result in results {
        let status = if result.is_failed() { "FAILED" } else { "PASSED" };
        let ops_per_sec = result
            .ops_per_sec()
            .map(|v| format_number(v))
            .unwrap_or_else(|| "-".to_string());
        let avg_ns = result
            .avg_ns()
            .map(|v| format_number(v))
            .unwrap_or_else(|| "-".to_string());
        let timestamp = result.timestamp.format("%H:%M:%S").to_string();

        md.push_str(&format!(
            "| {} | {} | {} | {} | {} |\n",
            result.target_id, status, ops_per_sec, avg_ns, timestamp
        ));
    }

    md.push('\n');

    // Failed benchmarks details
    let failed_results: Vec<_> = results.iter().filter(|r| r.is_failed()).collect();
    if !failed_results.is_empty() {
        md.push_str("## Failed Benchmarks\n\n");
        for result in failed_results {
            md.push_str(&format!("### {}\n\n", result.target_id));
            if let Some(error) = result.metrics.get("error") {
                md.push_str(&format!("**Error:** {}\n\n", error));
            }
        }
    }

    // Detailed metrics
    md.push_str("## Detailed Metrics\n\n");
    for result in results.iter().filter(|r| !r.is_failed()) {
        md.push_str(&format!("### {}\n\n", result.target_id));
        md.push_str("```json\n");
        md.push_str(
            &serde_json::to_string_pretty(&result.metrics).unwrap_or_else(|_| "{}".to_string()),
        );
        md.push_str("\n```\n\n");
    }

    // Footer
    md.push_str("---\n\n");
    md.push_str("*Generated by forge-benchmarks - Canonical benchmark interface for LLM-Forge*\n");

    md
}

/// Generates a compact single-line summary for CI/CD logs.
///
/// # Arguments
///
/// * `results` - Slice of benchmark results
///
/// # Returns
///
/// A single-line summary string.
pub fn generate_ci_summary(results: &[BenchmarkResult]) -> String {
    let total = results.len();
    let failed = results.iter().filter(|r| r.is_failed()).count();
    let passed = total - failed;

    let avg_ops: f64 = results
        .iter()
        .filter_map(|r| r.ops_per_sec())
        .sum::<f64>()
        / results.iter().filter(|r| r.ops_per_sec().is_some()).count().max(1) as f64;

    format!(
        "Benchmarks: {}/{} passed | Avg ops/sec: {:.0}",
        passed, total, avg_ops
    )
}

/// Formats a number with thousand separators for readability.
fn format_number(n: f64) -> String {
    if n >= 1_000_000.0 {
        format!("{:.2}M", n / 1_000_000.0)
    } else if n >= 1_000.0 {
        format!("{:.2}K", n / 1_000.0)
    } else {
        format!("{:.2}", n)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_generate_summary() {
        let results = vec![
            BenchmarkResult::new(
                "benchmark-1".to_string(),
                json!({"ops_per_sec": 1000000, "avg_ns": 1000}),
            ),
            BenchmarkResult::new(
                "benchmark-2".to_string(),
                json!({"ops_per_sec": 500000, "avg_ns": 2000}),
            ),
        ];

        let summary = generate_summary(&results);

        assert!(summary.contains("# LLM-Forge Benchmark Results"));
        assert!(summary.contains("benchmark-1"));
        assert!(summary.contains("benchmark-2"));
        assert!(summary.contains("**Total Benchmarks:** 2"));
        assert!(summary.contains("**Passed:** 2"));
    }

    #[test]
    fn test_generate_summary_with_failures() {
        let results = vec![
            BenchmarkResult::new("success".to_string(), json!({"ops_per_sec": 1000})),
            BenchmarkResult::failed("failure".to_string(), "Test error".to_string()),
        ];

        let summary = generate_summary(&results);

        assert!(summary.contains("**Failed:** 1"));
        assert!(summary.contains("## Failed Benchmarks"));
        assert!(summary.contains("Test error"));
    }

    #[test]
    fn test_ci_summary() {
        let results = vec![
            BenchmarkResult::new("b1".to_string(), json!({"ops_per_sec": 1000000})),
            BenchmarkResult::new("b2".to_string(), json!({"ops_per_sec": 2000000})),
        ];

        let summary = generate_ci_summary(&results);

        assert!(summary.contains("2/2 passed"));
        assert!(summary.contains("Avg ops/sec:"));
    }

    #[test]
    fn test_format_number() {
        assert_eq!(format_number(1_500_000.0), "1.50M");
        assert_eq!(format_number(15_000.0), "15.00K");
        assert_eq!(format_number(500.0), "500.00");
    }
}
